%% Init
clear all, close all, clc
rng(2023)

%% Generate data
n = 4;   % dim of data
N = 100; % number of data points
p = pi;  % learn p-norm for this p

X = cell(N,1);        % matrix whose col's are data points
dim_arr = zeros(N,1); % dimension / degree of each data point
for ii = 1:N
   dim = randi(n); % random dimension
   dim_arr(ii)=dim;

   m = randn(dim, 1); % random vector
    
   
   f_curr = norm(m,p); % evaluate function to be estimated:
   m = m./f_curr; % normalize data 
   
   X{ii} = m;
end
f_vals = ones(N,1);  % function values on (normalized) data

%% Set up description spaces
% We use description spaces U = W = Sym^2( Sym^{\leq k}( R^{2n+1} ) ) 
% with corresponding PSD cones. 
k = 1; 

d_V = 1; d_W = 2*k; d_U = 2*k; % generation degrees

% get generators for B_n:
Pi = zeros(n,n,3);
Pi(:,:,1) = eye(n); Pi(:,[1,2],1) = Pi(:,[2,1],1);
Pi(:,:,2) = eye(n); Pi(:,:,2) = Pi(:, [n,1:n-1],2);
Pi(:,:,3) = eye(n); Pi(1,1,3) = -1;

% get action of generators on R^{2n + 1}, viewed as two vectors and a scalar
Pib = zeros(2*n+1,2*n+1,3);
Pib(:,:,1) = blkdiag(Pi(:,:,1),Pi(:,:,1),1);
Pib(:,:,2) = blkdiag(Pi(:,:,2),Pi(:,:,2),1);
Pib(:,:,3) = eye(2*n+1); Pib(:,[1,n+1],3) = Pib(:,[n+1,1],3);

% get induced action of generators on polynomials in 2n+1 variables
x_ext = sdpvar(2*n+1,1); 
m_U = monolist(x_ext, k);            % monomials of degree <= k in 2n+1 variables
deg_list = get_deg_list(m_U, x_ext); % multi-degrees for each monomial
N_U = size(deg_list,1);              % size of matrices in U and W

Pi_U = gen_algebra_map(Pib, x_ext, deg_list); % get action of generators

%% Get bases for linear maps
% generate matrices whose kernels are spaces of extendable, equivariant linear maps
for ii = 1:size(Pi,3)
    % action of generators on symmetric matrices index by monomials:
    G = kron(sparse(Pi_U(:,:,ii)), sparse(Pi_U(:,:,ii)));

    % append equations for equivariance:
    K_A = [K_A; kron(sparse(Pi(:,:,ii))', speye(N_U^2)) - kron(speye(n), G)];
    K_B = [K_B; kron(speye(N_U^2),G) - kron(G',speye(N_U^2))];
end

% Since we represent symmetric matrices as full matrices, require linear
% maps to map symmetric matrices to symmetric matrices and act by zero on
% skew-symmetric matrices.
Tperm_U = gen_transpose_perm_mtx(N_U); % permutation matrices sending vec(X) to vec(X')
K_A = [K_A; kron(speye(n),Tperm_U) - speye(n*N_U^2)];
K_B = [K_B; kron(speye(N_U^2),Tperm_U) - speye(N_U^4)];
K_B = [K_B; kron(Tperm_U',speye(N_U^2)) - speye(N_U^4)];

% Add extendability conditions: [comment out to search over free descriptions without compatibility]

% generate embeddings
phi = cell(n,1); psi_U = cell(n,1); 
N_U = zeros(n, 1); % number of monomials for each dim.
for ii = 1:n
    [phi{ii}, psi_U{ii}] = get_embeddings(n, ii, k);
    N_U(ii) = round(sqrt(size(psi_U{ii},2)));
end

% add relevant equations
for ii = 1:d_V 
    K_A = [K_A; kron(phi{ii}', speye(N_U(end)^2) - psi_U{ii}*psi_U{ii}')];   % Ensure A extends to a morphism
end
for ii = 1:d_U 
    K_A = [K_A; kron(phi{ii}', speye(N_U(end)^2) - psi_U{ii}*psi_U{ii}')];   % Ensure A extends to a morphism
end

for ii = 1:d_W 
    K_B = [K_B; kron(psi_W{ii}', speye(N_U(end)^2) - psi_U{ii}*psi_U{ii}')]; % Ensure B extends to a morphism
end

for ii = 1:d_U 
    K_B = [K_B; kron(speye(N_W(end)^2) - psi_W{ii}*psi_W{ii}', psi_U{ii}')]; % Ensure B' extends to a morphism
end

% Find bases for kernels:
[~,SpRight] = spspaces(K_A,2); A_basis = SpRight{1}(:, SpRight{3});
[~,SpRight] = spspaces(K_B,2); B_basis = SpRight{1}(:, SpRight{3});

%% Optimize

T = 500; % number of alternations
num_inits = 500; % number of initializations

phi = eye(n); phi = sparse(phi(:,1:n_d));
phi_ext = eye(2*n+1); phi_ext = phi_ext(:, [1:n_d, n+1:n+n_d, 2*n+1]);
x_small_ext = sdpvar(2*n_d+1, 1);
deg_list_small = get_deg_list(monolist(x_small_ext, k), x_small_ext);
psi = gen_algebra_map(phi_ext, x_small_ext, deg_list_small);
psi = sparse(psi); psi = kron(psi,psi);

N_U = size(deg_list_small,1);

alpha_var = sdpvar(size(A_basis,2),1); A_var = psi'*reshape(A_basis*alpha_var,length(m_U)^2,[])*phi;
beta_var = sdpvar(size(B_basis,2),1); B_var = psi'*reshape(B_basis*beta_var,length(m_U)^2,[])*psi;
err = sdpvar(N,1);

t = sdpvar(N,1); 
t1 = sdpvar(1,1);
lambda_var = sdpvar(1,1); 

x_in = sdpvar(n_d,1);
f_pred_vals = zeros(size(f_vals));

err_rel_tol = 1e-3;
err_consec_iter_bnd = 5;

B_bnd = 1e4; lambda_min = 1e-3; lambda_init_max = 2;
ops = sdpsettings('solver','mosek','verbose',0,'debug',1);
p = 2; q = p/(p-1);

errs_per_init = zeros(num_inits, 1);
alpha_arr = zeros(size(A_basis,2), num_inits);
beta_arr = zeros(size(B_basis,2), num_inits);
lambda_arr = zeros(num_inits,1);

Y_vars = []; Z_vars = [];
for ii = 1:N
    Y_vars = [Y_vars, vec(sdpvar(N_U))];
    Z_vars = [Z_vars, vec(sdpvar(N_U))];
end
Y_arr = zeros(N_U^2, N);
Z_arr = zeros(N_U^2, N);

for init = 1:num_inits

    A = psi'*reshape(A_basis*randn(size(A_basis,2),1),length(m_U)^2,[])*phi;
    B = psi'*reshape(B_basis*randn(size(B_basis,2),1),length(m_U)^2,[])*psi;
    lambda_z = (lambda_init_max - lambda_min)*rand() + lambda_min;


    % % Alternate
    err_curr = zeros(T,1);
    for iter = 1:T
        F = [err >= 0, t >= 0];
        for ii = 1:N
            y = reshape(Y_vars(:,ii), N_U, N_U);
            z = reshape(Z_vars(:,ii), N_U, N_U);
            F = [F, t(ii) + lambda_z*norm(z(:),p) <= f_vals(ii) + err(ii)];
            F = [F, reshape(A*X(:,ii) + B*z(:), N_U,[]) + t(ii)*eye(N_U) >= 0];
            F = [F, -dot(y(:), A*X(:,ii)) >= f_vals(ii) - err(ii)];
            F = [F, norm(B'*y(:),q) <= lambda_z];
            F = [F, trace(y) <= 1, y >= 0];
        end
        diags = optimize(F, norm(err), ops);
        assert(diags.problem == 0)

        Y_arr = value(Y_vars);
        Z_arr = value(Z_vars);

        F = [err >= 0, t >= 0, norm(B_var(:)) <= B_bnd, lambda_var >= lambda_min];
        for ii = 1:N
            y_curr = reshape(Y_arr(:,ii), N_U, N_U);
            z_curr = reshape(Z_arr(:,ii), N_U, N_U);
            F = [F, t(ii) + lambda_var*norm(z_curr(:),p) <= f_vals(ii) + err(ii)];
            F = [F, reshape(A_var*X(:,ii) + B_var*z_curr(:), N_U, N_U) + t(ii)*eye(N_U) >= 0];
            F = [F, -dot(y_curr(:), A_var*X(:,ii)) >= f_vals(ii) - err(ii)];
            F = [F, norm(B_var'*y_curr(:), q) <= lambda_var];
        end
        diags = optimize(F, norm(err) + 1e-4*norm(beta_var,1), ops);
        assert(diags.problem == 0)

        A = value(A_var);
        B = value(B_var);
        lambda_z = value(lambda_var);

        prob_curr = optimizer([t1>=0, reshape(A*x_in(:) + B*z(:),N_U,[]) + t1*eye(N_U) >= 0],... 
            t1 + lambda_z*norm(z(:), p), ops, x_in(:), [t1;z(:)]);

        for ii = 1:N
            sln = prob_curr(X(:,ii));
            f_pred_vals(ii) = sln(1) + lambda_z*norm(sln(2:end), p);
        end
        err_actual = norm(f_pred_vals - f_vals)/norm(f_vals)
        err_bnd = norm(value(err))/norm(f_vals)

        err_curr(iter) = err_bnd;
        if iter > err_consec_iter_bnd
            err_rel_diff = 0;
            for jj = 1:err_consec_iter_bnd
                err_rel_diff = max(err_rel_diff, (err_curr(iter-jj)-err_curr(iter-jj+1))/err_curr(iter-jj));
            end
            if err_rel_diff < err_rel_tol
                break
            end
        end
    end
    errs_per_init(init) = norm(value(err))/norm(f_vals);
    alpha_arr(:,init) = value(alpha_var);
    beta_arr(:,init) = value(beta_var);
    lambda_arr(init) = lambda_z;
end
init_best = find(errs_per_init(1:init) == min(errs_per_init(1:init)));
disp(['Lowest training error = ' num2str(errs_per_init(init_best))])
A = reshape(A_basis*alpha_arr(:,init_best), N_U^2,n);
B = reshape(B_basis*beta_arr(:,init_best), N_U^2,N_U^2);
lambda_z = lambda_arr(init_best);

%% Generalize
m = 20; M = 1000;

Pi = zeros(m,m,3);
Pi(:,:,1) = eye(m); Pi(:,[1,2],1) = Pi(:,[2,1],1);
Pi(:,:,2) = eye(m); Pi(:,:,2) = Pi(:, [m,1:m-1],2);
Pi(:,:,3) = eye(m); Pi(1,1,3) = -1;

Pib = zeros(2*m+1,2*m+1,3);
Pib(:,:,1) = blkdiag(Pi(:,:,1),Pi(:,:,1),1);
Pib(:,:,2) = blkdiag(Pi(:,:,2),Pi(:,:,2),1);
Pib(:,:,3) = eye(2*m+1); Pib(:,[1,m+1],3) = Pib(:,[m+1,1],3);

x_ext_b = sdpvar(2*m+1,1);
v_b = monolist(x_ext_b, k);
deg_list_b = get_deg_list(v_b, x_ext_b);
num_mons_b = size(deg_list_b,1); % number of monomials

K_A = []; K_B = [];

Pi_U = gen_algebra_map(Pib, x_ext_b, deg_list_b);

for ii = 1:size(Pi,3)
    G = kron(sparse(Pi_U(:,:,ii)), sparse(Pi_U(:,:,ii)));
    K_A = [K_A; kron(sparse(Pi(:,:,ii))', speye(num_mons_b^2)) - kron(speye(m), G)];
    K_B = [K_B; kron(speye(num_mons_b^2),G) - kron(G',speye(num_mons_b^2))];
end

% Enforce symmetry:
vecperm = reshape(1:num_mons_b^2,num_mons_b,num_mons_b)'; vecperm = vecperm(:);
Pi = speye(num_mons_b^2); Pi = Pi(:,vecperm);
K_A = [K_A; kron(speye(m),Pi) - speye(m*num_mons_b^2)];
K_B = [K_B; kron(speye(num_mons_b^2),Pi) - speye(num_mons_b^4)];
K_B = [K_B; kron(Pi',speye(num_mons_b^2)) - speye(num_mons_b^4)];

% Add freeness
phi = eye(m); phi = sparse(phi(:,1:n));
phi_ext = eye(2*m+1); phi_ext = phi_ext(:, [1:n, m+1:m+n, 2*m+1]);
psi = gen_algebra_map(phi_ext, x_ext, deg_list);
psi = sparse(psi); psi = kron(psi,psi);

% Extend
A_big = lsqr([K_A; kron(phi',psi')],sparse([zeros(size(K_A,1),1); vec(A)]), 1e-16, 1e4);
B_big = lsqr([K_B; kron(psi',psi')],sparse([zeros(size(K_B,1),1); vec(B)]), 1e-16, 1e4);
A_big = reshape(A_big, num_mons_b^2, m);
B_big = reshape(B_big, num_mons_b^2, num_mons_b^2);

% Test
x_in_b = sdpvar(m,1); 
z_b = sdpvar(num_mons_b);
t1_b = sdpvar(1,1);
prob_big = optimizer([t1_b>=0, reshape(A_big*x_in_b + B_big*z_b(:),num_mons_b,[]) + t1_b*eye(num_mons_b) >= 0],... 
            t1_b + lambda_z*norm(z_b(:), p), ops, x_in_b, [t1_b;z_b(:)]);

X_test = randn(m,M);
f_test = zeros(M,1);
f_test_true = zeros(M,1);
for ii = 1:M
    sln = prob_big(X_test(:,ii));
    f_test(ii) = sln(1) + lambda_z*norm(sln(2:end), p);
    f_test_true(ii) = norm(X_test(:,ii),p);
end
err_test = norm(f_test - f_test_true)/norm(f_test_true)

%% Compute gen. error

err_arr = zeros(m,1);
for n_small = 1:m
    f_test = zeros(M,1);
    f_test_true = zeros(M,1);

    x_ext_small = sdpvar(2*n_small+1,1);
    deg_list_small = get_deg_list(monolist(x_ext_small,k),x_ext_small);
    phi = eye(m); phi = sparse(phi(:,1:n_small));
    phi_ext = eye(2*m+1); phi_ext = phi_ext(:, [1:n_small, m+1:m+n_small, 2*m+1]);
    psi = gen_algebra_map(phi_ext, x_ext_small, deg_list_small);
    psi = sparse(psi); psi = kron(psi,psi);

    A_small = psi'*A_big*phi;
    B_small = psi'*B_big*psi;
    x_b_small = sdpvar(n_small,1);
    z_b_small = sdpvar(size(deg_list_small,1));
    ext_prob_small = optimizer([t1>=0, reshape(A_small*x_b_small(:) + B_small*z_b_small(:),size(deg_list_small,1),[]) + t1*eye(size(deg_list_small,1)) >= 0],... 
        t1 + lambda_z*norm(z_b_small(:), p), ops, x_b_small(:), [t1;z_b_small(:)]);
    
    X_test = randn(n_small,M);
    for ii = 1:M
        sln = ext_prob_small(X_test(:,ii));
        f_test(ii) = sln(1) + lambda_z*norm(sln(2:end), p);
        f_test_true(ii) = norm(X_test(:,ii),p);
    end
    err_arr(n_small) = mean(abs(f_test - f_test_true)./f_test_true);
end
save('lPi_err_plot.mat','err_arr')
%% Plot gen. error w/ and w/o ext.
load('lPi_err_plot_noExt.mat','err_arr')
figure, plot(err_arr, 'linewidth', 4) 
hold on
load('lPi_err_plot.mat','err_arr')
plot(err_arr, 'linewidth', 4) 
xline(n_d, '--k', 'linewidth', 3)
xlabel('n'), ylabel('error'), legend({'Free', 'Free + Compatible', 'data'},'box','off', 'location', 'southeast')
set(gca,'fontsize',18)
set(gca, 'yscale', 'log')
exportgraphics(gcf,'lPi_learn.eps'); 

%% Plot 3D ball
n_small = 3;
x_ext_small = sdpvar(2*n_small+1,1);
deg_list_small = get_deg_list(monolist(x_ext_small,k),x_ext_small);
phi = eye(m); phi = sparse(phi(:,1:n_small));
phi_ext = eye(2*m+1); phi_ext = phi_ext(:, [1:n_small, m+1:m+n_small, 2*m+1]);
psi = gen_algebra_map(phi_ext, x_ext_small, deg_list_small);
psi = sparse(psi); psi = kron(psi,psi);

A_small = psi'*A_big*phi;
B_small = psi'*B_big*psi;
x_b_small = sdpvar(n_small,1);
z_b_small = sdpvar(size(deg_list_small,1));
ext_prob_small = optimizer([t1>=0, reshape(A_small*x_b_small(:) + B_small*z_b_small(:),size(deg_list_small,1),[]) + t1*eye(size(deg_list_small,1)) >= 0],...
    t1 + lambda_z*norm(z_b_small(:), p), ops, x_b_small(:), [t1;z_b_small(:)]);

[X,Y,Z] = meshgrid(-1.1:.1:1.1);

% lvl_set = 1; V = abs(X) + abs(Y) + abs(Z) - lvl_set; V2d = abs(x2d) + abs(y2d);
% lvl_set = .8; V = sqrt(X.^2 + Y.^2 + Z.^2) - lvl_set;  V2d = sqrt(x2d.^2 + y2d.^2);
lvl_set = 1; 
V = zeros(size(X));
for ii = 1:numel(X)
    sln = ext_prob_small([X(ii);Y(ii);Z(ii)]);
    V(ii) = sln(1) + lambda_z*norm(sln(2:end));
end
U = (abs(X).^p + abs(Y).^p + abs(Z).^p).^(1/p);
p = patch(isosurface(X, Y, Z, V, 1));
isonormals(X,Y,Z,V,p)
p.FaceColor = [0 0.4470 0.7410];
p.EdgeColor = 'none';
p.FaceAlpha = 0.75;
view(3)
% camlight 
% light
lightangle(-20,0)
lighting gouraud

%% Auxiliary function

function [phi, psi] = get_embeddings(n, n_0, k) % get embeddings V_{n_0} to V_n and U_{n_0} to U_n
phi = eye(n); phi = sparse(phi(:,1:n_0)); % embed R^{n_0} to R^n
phi_ext = eye(2*n+1); phi_ext = phi_ext(:, [1:n_0, n+1:n+n_0, 2*n+1]); % embed R^{2n_0+1} to R^{2n+1}

x_small_ext = sdpvar(2*n_0+1, 1);
deg_list_small = get_deg_list(monolist(x_small_ext, k), x_small_ext); % list of degrees for monomials in 2n_0+1 variables of degree <= k

psi = gen_algebra_map(phi_ext, x_small_ext, deg_list_small); % action of embeddings on monomials
psi = sparse(psi); psi = kron(psi,psi); % form embeddings acting on matrices
end
